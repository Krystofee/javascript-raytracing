<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }

      #main-canvas {
        border: 1px solid #00000030;
      }

      .flex {
        display: flex;
      }

      .flex.center {
        justify-content: center;
      }

      .mt-4 {
        margin-top: 4rem;
      }
    </style>
  </head>
  <body>
    <div class="flex center mt-4">
      <canvas id="main-canvas" width="1920" height="1080"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("main-canvas");
      const ctx = canvas.getContext("2d");

      if (ctx === null) {
        throw Error("Unable to initialize canvas");
      }

      const canvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      function drawPixel(x, y, color, sampleCount) {
        const divider = (1 / sampleCount) * 255;
        const r = color.x * divider;
        const g = color.y * divider;
        const b = color.z * divider;

        var index = (x + y * canvas.width) * 4;

        canvasData.data[index + 0] = r;
        canvasData.data[index + 1] = g;
        canvasData.data[index + 2] = b;
        canvasData.data[index + 3] = 255;
      }

      function updateCanvas() {
        ctx.putImageData(canvasData, 0, 0);
      }

      class Point3 {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }

        toString() {
          return `Vec3(${this.x}, ${this.y}, ${this.z})`;
        }
      }

      class Vec3 {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }

        toString() {
          return `Vec3(${this.x}, ${this.y}, ${this.z})`;
        }

        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }

        add(vec) {
          return new Vec3(this.x + vec.x, this.y + vec.y, this.z + vec.z);
        }

        sub(vec) {
          return new Vec3(this.x - vec.x, this.y - vec.y, this.z - vec.z);
        }

        mul(vec) {
          return new Vec3(this.x * vec.x, this.y * vec.y, this.z * vec.z);
        }

        mulNum(n) {
          return new Vec3(this.x * n, this.y * n, this.z * n);
        }

        divNum(n) {
          return this.mulNum(1 / n);
        }

        dot(vec) {
          return this.x * vec.x + this.y * vec.y + this.z * vec.z;
        }

        cross(vec) {
          return new Vec3(
            this.y * vec.z - vec.y * this.z,
            this.z * vec.x - vec.z * this.x,
            this.x * vec.y - vec.x * this.y
          );
        }

        unit() {
          return this.divNum(this.length());
        }

        distance(vec) {
          return vec.sub(this).length();
        }
      }

      class Ray {
        constructor(origin, dir) {
          this.origin = origin;
          this.dir = dir;
        }

        toString() {
          return `Ray(${this.origin}, ${this.dir})`;
        }

        at(t) {
          return this.origin.add(this.dir.mulNum(t));
        }
      }

      class HitData {
        constructor(at, normal, t) {
          this.at;
          this.normal = normal;
          this.t = t;
        }
      }

      class HitResult {
        constructor(isHit, data) {
          this.isHit = isHit;
          this.data = data;
        }

        static hit(ray, at, outNormal, t) {
          let normal;
          let isFront;
          if (ray.dir.dot(outNormal) > 0) {
            isFront = false;
            normal = outNormal.mulNum(-1);
          } else {
            normal = outNormal;
            isFront = true;
          }

          return new HitResult(true, new HitData(at, normal, t));
        }

        static miss() {
          return new HitResult(false, null);
        }
      }

      class Hittable {
        hit(ray, tMin, tMax) {
          throw Error("Not implemented error!");
        }
      }

      class HittableList {
        constructor() {
          this.objects = [];
        }

        add(obj) {
          this.objects.push(obj);
        }

        hit(ray, tMin, tMax) {
          let result = HitResult.miss();
          let closest = tMax;

          this.objects.forEach((obj) => {
            const objResult = obj.hit(ray, tMin, closest);
            if (objResult.isHit) {
              result = objResult;
              closest = objResult.data.t;
            }
          });

          return result;
        }
      }

      class Sphere extends Hittable {
        constructor(center, radius) {
          super();
          this.center = center;
          this.radius = radius;
        }

        toString() {
          return `Sphere(${this.center}, ${this.radius})`;
        }

        hit(ray, tMin, tMax) {
          const oc = ray.origin.sub(this.center);
          const a = ray.dir.dot(ray.dir);
          const b = oc.dot(ray.dir) * 2;
          const c = oc.dot(oc) - this.radius * this.radius;
          const discriminant = b * b - 4 * a * c;

          if (discriminant < 0) {
            return HitResult.miss();
          }

          let root = (-b - Math.sqrt(discriminant)) / (2 * a);
          if (root < tMin || root > tMax) {
            root = (-b + Math.sqrt(discriminant)) / (2 * a);
            if (root < tMin || root > tMax) {
              return false;
            }
          }

          const at = ray.at(root);
          const outNormal = at.sub(this.center).divNum(this.radius);
          return HitResult.hit(ray, at, outNormal, root);
        }
      }

      const world = new HittableList();
      world.add(new Sphere(new Vec3(0, 0, -1), 0.5));
      world.add(new Sphere(new Vec3(0, -100.5, -1), 100));

      const aspectRatio = canvas.width / canvas.height;

      const viewportHeight = 2;
      const viewportWidth = viewportHeight * aspectRatio;
      const focalLength = 1;

      //camera
      const origin = new Vec3(0, 0, 0);
      const horizontal = new Vec3(viewportWidth, 0, 0);
      const vertical = new Vec3(0, viewportHeight, 0);
      const lowerLeftCorner = origin
        .sub(horizontal.divNum(2))
        .sub(vertical.divNum(2))
        .sub(new Vec3(0, 0, focalLength));

      function rayColor(ray) {
        const result = world.hit(ray, 0, Infinity);
        if (result.isHit) {
          return new Vec3(
            result.data.normal.x + 1,
            result.data.normal.y + 1,
            result.data.normal.z + 1
          ).mulNum(0.5);
        }

        const unitDir = ray.dir.unit();
        const t = 0.5 * (unitDir.y + 1.0);
        return new Vec3(1, 1, 1)
          .mulNum(1.0 - t)
          .add(new Vec3(0.5, 0.6, 1).mulNum(t));
      }

      const sampleCount = 10;

      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          let color = new Vec3(0, 0, 0);

          for (let i = 0; i < sampleCount; i++) {
            const u = (x + Math.random()) / (canvas.width - 1);
            const v = (y + Math.random()) / (canvas.height - 1);

            const r = new Ray(
              origin,
              lowerLeftCorner
                .add(horizontal.mulNum(u))
                .add(vertical.mulNum(v))
                .sub(origin)
            );

            color = color.add(rayColor(r));
          }

          drawPixel(x, canvas.height - y, color, sampleCount);
        }
      }

      updateCanvas();
    </script>
  </body>
</html>
